#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res, xlabel = "Distancia (m))")
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res) + xlab("Distancia (m)")
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res, ylabel = "Distancia (m)")
# Agregando las observaciones centradas por la media general
gg_rf(futbol, dist, ajuste, res, cen_obs = TRUE, ylabel = "Distancia (m)")
gg_sl(futbol2, dist, longp)
#' @importFrom magrittr %>%
#' @importFrom dplyr enquo
#' @export
#' @examples
#' data(fusion)
#' gg_sl(fusion, time, nv.vv)
#' gg_sl(fusion, time, nv.vv, jitterwidth = 0.4, linecol = "blue",
#'       ylabel = "hola", jitteralpha = 1) +
#'       ggplot2::scale_color_discrete("Grupo")
#'
gg_sl <- function(df, vble, group,
jitterwidth = 0.1, jitteralpha = 0.5, linecol = "red",
ylabel = expression(sqrt(abs( " Residuos "))),
xlabel = "Medians") {
# NSE y controles
if (!is.data.frame(df)) stop("The object provided in the argument df is not a data.frame")
vble <- enquo(vble)
group <- enquo(group)
if (!is.numeric(eval_tidy(vble, df)))
stop(paste(quo_text(vble), "provided for the vble argument is not a numeric variable"))
if (!is.character(eval_tidy(group, df)) && !is.factor(eval_tidy(group, df)))
stop(paste(quo_text(group), "provided for the group argument is neither a character nor a factor variable"))
if (length(unique(pull(df, !!group))) < 2) stop("There's only one group")
# Calcular mediana y residuos
df1 <-
df %>%
group_by(!!group) %>%
mutate(
mna = median(!!vble),
mna_res = sqrt(abs(!!vble - .data$mna))
)
# Preparar otro data set para unir las medianas de los residuos
datos_linea <-
df1 %>%
group_by(!!group) %>%
summarise(x = median(!!vble), y = median(.data$mna_res))
# Gráfico s-l
g <- ggplot(df1, aes(x = .data$mna, y = .data$mna_res, color = !!group)) +
geom_jitter(alpha = jitteralpha, width = jitterwidth, height = 0) +
geom_line(data = datos_linea, aes(x = .data$x, y = .data$y), col = linecol) +
ylab(ylabel) + xlab(xlabel)
return(g)
}
gg_sl(futbol2, dist, longp, xlabel = "Mediana de distanci jittered (m)")
gg_pt(futbol2, dist)
gg_pt(futbol2, dist, taus = c(-1, -0.5, 0, 0.5))
# Para cada grupo por separado
gg_pt(futbol2, dist, longp, taus = c(-1, -0.5, 0, 0.5))
library(ggcleveland)
usethis::use_vignette()
usethis::use_vignette("ggplot-cleveland")
devtools::build_vignettes()
usethis::use_news_md()
usethis::use_news_md()
pkgdown::build_site()
library(ggcleveland)
devtools::build_vignettes()
pkgdown::build_site()
devtools::build_vignettes()
pkgdown::build_site()
pkgdown::build_site()
library(ggcleveland)
# Paquetes
library(ggplot2)
library(dplyr)
library(readr)
library(tidyr)
library(here)
library(cowplot)
library(GGally)
library(ggridges)
# devtools::install_github("mpru/ggcleveland")
library(ggcleveland)
# Setear estilo para los gráficos
theme_set(theme_bw() + theme(panel.spacing = unit(0, "lines")))
datos <- read_delim(here("data", "futbol.txt"), "\t")
datos <- futbol
datos %>%
group_by(longp) %>%
summarise(
Q1 = quantile(dist, .25),
Q2 = quantile(dist, .5),
Q3 = quantile(dist, .75)
)
datos %>%
filter(longp == "< 0.81 m") %>%
ggplot(aes(sample = dist)) +
stat_qq(distribution = qunif, geom = "line") +
stat_qq(distribution = qunif, geom = "point") +
xlab(expression(f[i])) + ylab("Distancia (mts)")
ggplot(datos, aes(sample = dist)) +
stat_qq(distribution = qunif) +
facet_wrap(~ longp) +
xlab(expression(f[i])) + ylab("Distancia (mts)")
# Genero un dataset para cada grupo
grupo1 <- filter(datos, longp == "< 0.81 m")
grupo2 <- filter(datos, longp == "0.81 a 0.90 m")
qqplot(x = grupo1$dist, y = grupo2$dist, plot.it = F) %>%
as_tibble() %>%
ggplot(aes(x = x, y = y)) +
geom_point() +
geom_abline(intercept = 0, slope = 1) +
coord_fixed(xlim = c(30, 80), ylim = c(30, 80)) +
xlab("< 0.81 m") + ylab("0.81 a 0.90 m")
datos2 <- filter(datos, longp %in% c("< 0.81 m", "0.81 a 0.90 m"))
gg_quantiles(datos2, dist, longp)
gg_quantiles(datos, dist, longp, size = 0.5)
qqplot(x = grupo1$dist, y = grupo2$dist, plot.it = F) %>%     # calculo cuantiles
as_tibble() %>%                                             # paso matriz a tibble
mutate(resta = y - x, media = (x +  y) / 2) %>%             # calculo restas y medias
ggplot(aes(x = media, y = resta)) +                         # grafico
geom_point() +
geom_hline(yintercept = 0)
gg_tmd(datos, dist, longp, size = 0.5, color = "red")
# Para un grupo
datos %>%
filter(longp == "< 0.81 m") %>%
ggplot(aes(y = dist, x = "")) +
geom_boxplot(width = 0.5, fill = "lightgray") +
xlab("") + ylab("Distancia (m)") +
theme(axis.ticks.x = element_blank())
# Para varios grupos
ggplot(datos, aes(y = dist, x = longp)) +
geom_boxplot(width = 0.5, fill = "lightgray") +
xlab("Longitud de pierna") + ylab("Distancia (m)") +
coord_flip()
ggplot(datos, aes(y = dist, x = longp, fill = longp)) +
geom_jitter(width = 0.25, height = 0) +
geom_boxplot(width = 0.5, outlier.shape = NA, notch = T) +
coord_flip() +
labs(x = "Longitud de pierna", y = "Distancia (m)") +
theme(legend.position="none")
ggplot(datos, aes(y = dist, x = longp, fill = longp)) +
geom_boxplot(varwidth = T) +
coord_flip() +
labs(x = "Longitud de pierna", y = "Distancia (m)") +
theme(legend.position="none")
ggplot(grupo1, aes(x = dist)) +
geom_histogram(aes(y = ..density..), fill = "lightgray", col = "black", breaks = seq(25, 85, 10)) +
scale_x_continuous(breaks = seq(25, 85, 10)) +
labs(x = "Distancia (m)", y = "Densidad")
ggplot(grupo1, aes(x = dist)) +
stat_density(fill = "lightgray", col = "black")
g1 <- ggplot(grupo1, aes(x = dist)) +
stat_density(fill = "lightgray", col = "black")
g2 <- ggplot(grupo1, aes(x = dist)) +
stat_density(fill = "lightgray", col = "black", bw = 1)
g3 <- ggplot(grupo1, aes(x = dist)) +
stat_density(fill = "lightgray", col = "black", bw = 20)
g4 <- ggplot(grupo1, aes(x = dist)) +
stat_density(fill = "lightgray", col = "black", kernel = "rectangular")
plot_grid(g1, g2, g3, g4, nrow = 2)
datos %>%
filter(longp %in% c("< 0.81 m", "0.91 a 1.00 m", "1.21 m y +")) %>%
ggplot(aes(x = dist, fill = longp, color = longp)) +
geom_density(alpha = 0.4)
ggplot(datos, aes(y = longp, x = dist, fill = longp)) +
geom_density_ridges() +
theme_ridges() +
theme(legend.position = "none") +
labs(x = "Distancia (m)", y = "Longitud de pierna (m)")
ggplot(datos, aes(y = dist, x = longp, fill = longp)) +
geom_violin() +
theme(legend.position = "none") +
labs(x = "Longitud de pierna (m)", y = "Distancia (m)")
# Con puntos
ggplot(datos, aes(y = dist, x = longp, fill = longp)) +
geom_jitter(width = 0.25, height = 0) +
geom_violin(alpha = 0.4) +
theme(legend.position = "none") +
labs(x = "Longitud de pierna (m)", y = "Distancia (m)")
# Cuantiles de los datos
g1 <-
datos %>%
filter(longp == "1.01 a 1.10 m") %>%
ggplot(aes(sample = dist)) +
stat_qq(distribution = qunif) +
stat_qq(distribution = qunif, geom = "line") +
xlab(expression(f[i])) + ylab("Distancia para longitud de pierna entre 1.01 y 1.10 m") +
ylim(c(40, 100)) +
ggtitle("Cuantiles de los datos")
# Cuantiles de una distribución normal con media y variancia iguales a los de la
# muestra
media <- mean(datos$dist[datos$longp == "1.01 a 1.10 m"])
desvio <- sd(datos$dist[datos$longp == "1.01 a 1.10 m"])
datos_graf <- tibble(
# Elijo una secuencia de 50 valores dentro del rango observado
y = seq(min(datos$dist), max(datos$dist), length.out = 50),
x = pnorm(y, media, desvio)
)
g2 <- ggplot(datos_graf, aes(x = x, y = y)) +
geom_line() +
ylim(c(40, 100)) + ylab("") + xlab("f") +
ggtitle("Cuantiles normales")
plot_grid(g1, g2, labels = c('A', 'B'))
g1
g2
ggplot(datos_graf, aes(x = x, y = y)) +
geom_line() +
ylim(c(40, 100)) +
# ylab("") + xlab("f") +
ggtitle("Cuantiles normales")
View(datos_graf)
ggplot(datos_graf, aes(x = x, y = y)) +
geom_line() +
# ylim(c(40, 100)) +
ylab("") + xlab("f") +
ggtitle("Cuantiles normales")
g2 <- ggplot(datos_graf, aes(x = x, y = y)) +
geom_line() +
# ylim(c(40, 100)) +
ylab("") + xlab("f") +
ggtitle("Cuantiles normales")
plot_grid(g1, g2, labels = c('A', 'B'))
summary(datos_graf$y)
g2 <- ggplot(datos_graf, aes(x = x, y = y)) +
geom_line() +
ylim(c(25, 120)) + ylab("") + xlab("f") +
ggtitle("Cuantiles normales")
plot_grid(g1, g2, labels = c('A', 'B'))
g2 <- ggplot(datos_graf, aes(x = x, y = y)) +
geom_line() +
ylim(c(30, 115)) + ylab("") + xlab("f") +
ggtitle("Cuantiles normales")
plot_grid(g1, g2, labels = c('A', 'B'))
g2 +
stat_qq(aes(sample = dist, y = ..sample.., x = ..theoretical..),
data = filter(datos, longp == "1.01 a 1.10 m"),
distribution = qunif) +
ylab("Distancia para longitud de pierna entre 1.01 y 1.10 m") +
ggtitle("")
ggplot(datos, aes(sample = dist)) +
stat_qq(size = 0.7) +
stat_qq_line() +
facet_wrap(~ longp) +
labs(x = "Cuantil normal", y = "Distancia (m)")
# El cálculo de los valores f ya lo teníamos hecho pero repito
datos <-
datos %>%
group_by(longp) %>%
arrange(dist) %>%
mutate(valorf = (row_number() - 0.5) / n(), cuantil_normal = qnorm(valorf))
# Buscar la recta que pasa por los Q1s y Q3s
datos_recta <-
datos %>%
# Este group_by es redudante, ya lo agrupé antes, pero lo dejo por claridad
group_by(longp) %>%
summarise(
q1 = quantile(dist, 0.25),
q3 = quantile(dist, 0.75),
q1normal = qnorm(0.25),
q3normal = qnorm(0.75),
pendiente = (q3 - q1) / (q3normal - q1normal),
ordenada = q1 - pendiente * q1normal
)
ggplot(datos, aes(x = cuantil_normal, y = dist)) +
geom_point(size = 0.7) +
facet_wrap(~ longp) +
geom_abline(data = datos_recta,
aes(intercept = ordenada, slope = pendiente), col = "blue") +
labs(x = "Cuantil normal", y = "Distancia (m)")
ggplot(datos, aes(y = dist, x = longp)) +
stat_summary(fun.y = "mean", geom = "point") +
coord_flip() +
labs(y = "Media de distancia (m)", x = "Longitud de pierna")
ggplot(datos, aes(y = dist, x = longp)) +
geom_jitter(width = 0.2, height = 0, alpha = 0.3) +
stat_summary(fun.y = "mean", geom = "point", col = "orange", size = 4) +
coord_flip() +
labs(y = "Distancia (m)", x = "Longitud de pierna")
# Ajuste
datos <-
datos %>%
group_by(longp) %>%
mutate(ajuste = mean(dist), res = dist - ajuste)
# Gráfico
ggplot(datos, aes(y = res, x = longp)) +
geom_boxplot(width = 0.5, fill = "lightgray") +
coord_flip() +
labs(y = "residuos", x = "longitud de pierna")
# Incorporamos esto en la función gg_cuantiles
gg_quantiles(datos, res, longp, combined = TRUE,
xlabel = "Cuantiles de los residuos combinados",
ylabel = "Cuantiles de los residuos de cada grupo")
datos %>%
ggplot(aes(sample = res)) +
stat_qq(distribution = qunif) +
xlab(expression(f[i])) + ylab("Residuos Distancia (m)")
datos %>%
ungroup() %>%
summarise(
p2.5 = quantile(res, 0.025),
p97.5 = quantile(res, 0.975)
)
summarise(datos, mean(dist))
ggplot(datos, aes(sample = res)) +
stat_qq(size = 0.7) +
stat_qq_line()
gg_rf(datos, dist, ajuste, res,
ylabel = "Distancia (m)",
cen_fit_label = "Valores ajustados centrados",
res_label = "Residuos")
gg_rf(datos, dist, ajuste, res, cen_obs = TRUE,
ylabel = "Distancia (m)",
cen_obs_label = "Valores observados centrados",
cen_fit_label = "Valores ajustados centrados",
res_label = "Residuos")
datos <- fusion
ggplot(datos, aes(sample = time)) +
stat_qq(distribution = qunif) +
facet_wrap(~ nv.vv) +
xlab(expression(f[i])) + ylab("Tiempo (segundos)")
ggplot(datos, aes(sample = time)) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ nv.vv) +
xlab("Cuantil normal") + ylab("Tiempo (segundos)")
ggplot(datos, aes(y = time, x = nv.vv)) +
geom_boxplot(width = 0.5, fill = "lightgray") +
ylab("Tiempo (segundos)") + xlab("") +
coord_flip()
ggplot(datos, aes(sample = log2(time))) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ nv.vv) +
xlab("Cuantil normal") + ylab("Tiempo (segundos)")
gg_sl(datos, time, nv.vv, xlabel = "Mediana de tiempo jittered (seg)") +
scale_color_discrete("Grupo")
datos <- mutate(datos, time_log = log2(time))
gg_sl(datos, time_log, nv.vv, xlabel = "Mediana de log tiempo jittered (log2 seg)") +
scale_color_discrete("Grupo")
g1 <- gg_quantiles(datos, time, nv.vv,
xlabel = "Tiempo NV (segundos)",
ylabel = "Tiempo VV (segundos)") +
ylim(c(0, 50)) + xlim(c(0, 50)) +
ggtitle("Escala original")
g2 <- gg_quantiles(datos, time_log, nv.vv,
xlabel = "Tiempo NV (log2 seg)",
ylabel = "Tiempo VV (log2 seg)") +
ggtitle("Escala logarítmica")
plot_grid(g1, g2, labels = "AUTO", align = "h")
gg_tmd(datos, time_log, nv.vv) +
geom_hline(yintercept = -0.6, lty = 2, col = "red")
# Ajustar la media al log time y calcular residuos
datos <-
datos %>%
group_by(nv.vv) %>%
mutate(
ajuste_log = mean(time_log),
res_log = time_log - ajuste_log
)
gg_quantiles(datos, res_log, nv.vv, combined = T)
ggplot(datos, aes(sample = res_log)) +
stat_qq() +
stat_qq_line() +
xlab("Cuantil normal") + ylab("Residuos Log Tiempo (log2 seg)")
gg_rf(datos, time_log, ajuste_log, res_log, cen_obs = TRUE,
ylabel = "Log Tiempo (log2 seg)")
# Sólo grupo VV
datos %>%
filter(nv.vv == "VV") %>%
gg_pt(time, ylabel = "Tiempo VV transformado", xlabel = "Cuantiles normales")
# Ambos grupos
gg_pt(datos, time, nv.vv)
load("~/gdrive/Facultad/ADE_Maestria/2020/data/food.txt")
library(readr)
datos <- read_delim("~/gdrive/Facultad/ADE_Maestria/2020/data/food.txt",
"\t", escape_double = FALSE, trim_ws = TRUE)
View(datos)
# Gráfico de percentiles
ggplot(datos, aes(sample = mean.length)) +
stat_qq(distribution = qunif) +
facet_wrap(~ dimension) +
xlab("valor f") + ylab("Longitud de cadena")
# Gráfico s-l
gg_sl(datos, mean.length, dimension,
xlabel = "Mediana de longitud de cadena jittered")
# QQ normal
ggplot(datos, aes(sample = mean.length)) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ dimension) +
xlab("Cuantil normal") + ylab("Longitud de cadena")
# Transformar
datos <- mutate(datos, mean.length_log = log2(mean.length))
# S-L
gg_sl(datos, mean.length_log, dimension, jitterwidth = 0.05,
xlabel = "Mediana log2 longitud de cadena jittered")
# QQ Normal
ggplot(datos, aes(sample = mean.length_log)) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ dimension) +
xlab("Cuantil normal") + ylab("Log2 Longitud de cadena")
# Transformar
datos <- mutate(datos, mean.length_inv = mean.length ^ (-1))
# S-L
gg_sl(datos, mean.length_inv, dimension, jitterwidth = 0.01,
xlabel = "Mediana de Link Fraction jittered")
# QQ normal
ggplot(datos, aes(sample = mean.length_inv)) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ dimension) +
xlab("Cuantil normal") + ylab("Link Fraction Longitud de cadena")
# Ajustar la media al link fraction y calcular residuos
datos <-
datos %>%
group_by(dimension) %>%
mutate(
ajuste = mean(mean.length_inv),
res = mean.length_inv - ajuste
)
# Gráfico de cuantiles combinados
gg_quantiles(datos, res, dimension, combined = T)
# Gráfico R-F
gg_rf(datos, mean.length_inv, ajuste, res, cen_obs = TRUE, ylabel = "Link Fraction")
library(readr)
datos <- read_delim("~/gdrive/Facultad/ADE_Maestria/2020/data/bin.txt",
"\t", escape_double = FALSE, trim_ws = TRUE)
View(datos)
# Agrego una columna con number.runs como factor, para tenerla en ambas
# modalidades, dependiendo de lo que convenga la uso numérica o factor
datos <- mutate(datos, number.runs.factor = factor(number.runs))
# Boxplots
ggplot(datos, aes(y = empty.space, x = number.runs.factor)) +
geom_boxplot(width = 0.5, fill = "lightgray") +
scale_y_continuous(trans = "log2") +
ylab("Número de corridas") + xlab("Log2 espacio vacío") +
coord_flip()
# QQ normales
datos <- mutate(datos, empty.space_log = log2(empty.space))
ggplot(datos, aes(sample = empty.space_log)) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ number.runs.factor) +
xlab("Cuantil normal") + ylab("Log2 espacio vacío")
datos <-
datos %>%
group_by(number.runs.factor) %>%
mutate(
mna = median(empty.space_log),
res = empty.space_log - mna,
mad = median(abs(res)),
res_est = res / mad
)
# QQ plots normales de residuos estandarizados por dispersión
ggplot(datos, aes(sample = res_est)) +
stat_qq() +
stat_qq_line() +
facet_wrap(~ number.runs.factor) +
xlab("Cuantil normal") + ylab("Res Est por Dispersión Log2 Espacio Vacío")
datos2 <- filter(datos, number.runs >= 2000)
gg_quantiles(datos2, res_est, number.runs.factor, T)
ggplot(datos2, aes(sample = res_est)) +
stat_qq() +
stat_qq_line()
# Lo de la pendiente 1/3 es un conocimiento previo, teórico.
medianas <-
datos %>%
mutate(number.runs_log = log2(number.runs)) %>%
group_by(number.runs_log) %>%
summarise(mna_log = median(empty.space_log))
ggplot(medianas, aes(x = number.runs_log, y = mna_log)) +
geom_point() +
scale_x_continuous("Log2 Nro de pesos", breaks = seq(7, 17, 2)) +
ylab("Mediana Log2 Espacio Vacio") +
geom_abline(slope = 1/3, intercept = medianas$mna_log[nrow(medianas)] - medianas$number.runs_log[nrow(medianas)] / 3)
datos_graf <-
datos %>%
group_by(number.runs) %>%
summarise(
mna = median(empty.space_log),
mad = median(abs(res)),
mad_log = log2(mad)
) %>%
mutate(number.runs_log = log2(number.runs))
ggplot(datos_graf, aes(x = number.runs_log, y = mad_log)) +
geom_point() +
scale_x_continuous("Log2 Nro de pesos", breaks = seq(7, 17, 2)) +
ylab("Log2 Mads de Log2 Espacio Vacio")
datos_graf <- mutate(datos_graf, mad_rel_log = log2(mad / min(mad)))
ggplot(datos_graf, aes(x = mna, y = mad_rel_log)) +
geom_point() +
xlab("Mediana log2 Espacio Vacío") +
ylab("Log2 Dispersión Relativa")
datos_graf <-
datos %>%
group_by(number.runs) %>%
mutate(res = empty.space - median(empty.space)) %>%
summarise(
mna = median(empty.space),
mad = median(abs(res))
) %>%
mutate(mad_rel_log = log2(mad / min(mad)))
ggplot(datos_graf, aes(x = mna, y = mad_rel_log)) +
geom_point() +
xlab("Mediana Espacio Vacío") +
ylab("Log2 Dispersión Relativa")
setwd("/home/marcos/Desktop/prueba")
