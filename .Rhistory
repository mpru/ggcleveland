# Para cada combinacion de grupos aplicar la funcion anterior y combinar los
# resultantes tibbles
rtdo <- mapply(aux, grilla$grupoX, grilla$grupoY, SIMPLIFY = F) %>% bind_rows()
# Hago un dataset para agregar como texto los nombres de las variables en los
# paneles de la diagonal
dataTexto <- tibble(varX = grupos, varY = grupos)
# Grafico
g <- ggplot(rtdo, aes(x = x, y = y)) +
geom_point(...) +
geom_abline(aes(intercept = 0, slope = 1)) +
facet_grid(varY ~ varX) +
geom_text(data = dataTexto,
mapping = aes(y = mean(range(rtdo$y)), x = mean(range(rtdo$x)),
label = dataTexto$varX)) +
xlab(vble) + ylab(vble)
}
xlabel <- ifelse(!is.null(xlabel), xlabel,
ifelse(combined, "Quantiles of combined data",
ifelse(length(groups) == 2, grupos[1], quo_text(vble))))
ylabel <- ifelse(!is.null(ylabel), ylabel,
ifelse(combined, "Quantiles of each group",
ifelse(length(groups) == 2, grupos[2], quo_text(vble))))
g <- g + labels(x = xlabel, y = ylabel)
return(g)
}
gg_quantiles(futbol2, dist, longp)
#' # Multiple groups
#' gg_quantiles(futbol, dist, longp)
#' gg_quantiles(futbol, dist, longp, size = 0.4, color = "red", shape = 3)
#'
#' # Only 2 grupos
#' futbol2 <- dplyr::filter(futbol, longp %in% c("< 0.81 m", "0.81 a 0.90 m"))
#' gg_quantiles(futbol2, dist, longp)
#'
#' # Each groups vs quantiles from all groups combined
#' gg_quantiles(futbol, dist, longp, combined = TRUE)
gg_quantiles <- function(df, vble, group, combined = FALSE,
xlabel = NULL, ylabel = NULL, ...) {
# NSE y controles
if (!is.data.frame(df)) stop("The object provided in the argument df is not a data.frame")
vble <- enquo(vble)
group <- enquo(group)
if (!is.numeric(eval_tidy(vble, df)))
stop(paste(quo_text(vble), "provided for the vble argument is not a numeric variable"))
if (!is.character(eval_tidy(group, df)) && !is.factor(eval_tidy(group, df)))
stop(paste(quo_text(group), "provided for the group argument is neither a character nor a factor variable"))
if (!is.logical(combined)) stop("Argument combined must be either TRUE or FALSE")
df <- ungroup(df) # si esta agrupada no deja modificar esa vble
# Identificar los grupos
grupos <- unique(pull(df, !!group))
if (length(grupos) < 2) stop("There's only one group")
if (combined) {
# Grafico de cuantiles de cada grupo vs cuantiles combinados, en paneles (diapo 37)
df <-
df %>%
group_by(!!group)  %>%
arrange(!!vble)  %>%
mutate(valorf = (row_number() - 0.5) / n())  %>%
# desagrupar para que no siga haciendo cálculos para cada grupo de longp
ungroup() %>%
# con todos los datos, calcular el cuantil que acumula la misma probabilidad que cada dato
mutate(cuantilComb = quantile(!!vble, .data$valorf))
g <- ggplot(df, aes(y = !!vble, x = .data$cuantilComb)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
facet_wrap(vars(!!group))
} else if (length(grupos) == 2) {
# Dos grupos, un solo grafico de cuantiles (diapo 13)
x <- df %>% filter(!!group == grupos[1]) %>% pull(!!vble)
y <- df %>% filter(!!group == grupos[2]) %>% pull(!!vble)
g <- qqplot(x = x, y = y, plot.it = F) %>%
as_tibble() %>%
ggplot(aes(x = x, y = y)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
coord_fixed() +
xlab(grupos[1]) + ylab(grupos[2])
} else {
# Mas de dos grupos, matriz de scatterplots de graficos de cuantiles (diapo 18)
# Grilla con las combinaciones de los grupos, saco los que son iguales (la diagonal)
grilla <-
expand.grid(grupos, grupos, stringsAsFactors = F) %>%
rename(grupoX = .data$Var1, grupoY = .data$Var2) %>%
filter(.data$grupoX != .data$grupoY)
# Funcion auxiliar para mapply, dados los nombres de dos grupos genera los
# cuantiles a graficar gx e gy son los nombres de los grupos, devuelve un
# tibble
aux <- function(gx, gy) {
x <- df %>% filter(!!group == gx) %>% pull(!!vble)
y <- df %>% filter(!!group == gy) %>% pull(!!vble)
dat <- qqplot(x, y, plot.it = F) %>% as_tibble()
dat$varX <- gx
dat$varY <- gy
return(dat)
}
# Para cada combinacion de grupos aplicar la funcion anterior y combinar los
# resultantes tibbles
rtdo <- mapply(aux, grilla$grupoX, grilla$grupoY, SIMPLIFY = F) %>% bind_rows()
# Hago un dataset para agregar como texto los nombres de las variables en los
# paneles de la diagonal
dataTexto <- tibble(varX = grupos, varY = grupos)
# Grafico
g <- ggplot(rtdo, aes(x = x, y = y)) +
geom_point(...) +
geom_abline(aes(intercept = 0, slope = 1)) +
facet_grid(varY ~ varX) +
geom_text(data = dataTexto,
mapping = aes(y = mean(range(rtdo$y)), x = mean(range(rtdo$x)),
label = dataTexto$varX)) +
xlab(vble) + ylab(vble)
}
xlabel <- ifelse(!is.null(xlabel), xlabel,
ifelse(combined, "Quantiles of combined data",
ifelse(length(groups) == 2, grupos[1], quo_text(vble))))
ylabel <- ifelse(!is.null(ylabel), ylabel,
ifelse(combined, "Quantiles of each group",
ifelse(length(groups) == 2, grupos[2], quo_text(vble))))
g <- g #+ labels(x = xlabel, y = ylabel)
return(g)
}
gg_quantiles(futbol2, dist, longp)
#' # Multiple groups
#' gg_quantiles(futbol, dist, longp)
#' gg_quantiles(futbol, dist, longp, size = 0.4, color = "red", shape = 3)
#'
#' # Only 2 grupos
#' futbol2 <- dplyr::filter(futbol, longp %in% c("< 0.81 m", "0.81 a 0.90 m"))
#' gg_quantiles(futbol2, dist, longp)
#'
#' # Each groups vs quantiles from all groups combined
#' gg_quantiles(futbol, dist, longp, combined = TRUE)
gg_quantiles <- function(df, vble, group, combined = FALSE,
xlabel = NULL, ylabel = NULL, ...) {
# NSE y controles
if (!is.data.frame(df)) stop("The object provided in the argument df is not a data.frame")
vble <- enquo(vble)
group <- enquo(group)
if (!is.numeric(eval_tidy(vble, df)))
stop(paste(quo_text(vble), "provided for the vble argument is not a numeric variable"))
if (!is.character(eval_tidy(group, df)) && !is.factor(eval_tidy(group, df)))
stop(paste(quo_text(group), "provided for the group argument is neither a character nor a factor variable"))
if (!is.logical(combined)) stop("Argument combined must be either TRUE or FALSE")
df <- ungroup(df) # si esta agrupada no deja modificar esa vble
# Identificar los grupos
grupos <- unique(pull(df, !!group))
if (length(grupos) < 2) stop("There's only one group")
if (combined) {
# Grafico de cuantiles de cada grupo vs cuantiles combinados, en paneles (diapo 37)
df <-
df %>%
group_by(!!group)  %>%
arrange(!!vble)  %>%
mutate(valorf = (row_number() - 0.5) / n())  %>%
# desagrupar para que no siga haciendo cálculos para cada grupo de longp
ungroup() %>%
# con todos los datos, calcular el cuantil que acumula la misma probabilidad que cada dato
mutate(cuantilComb = quantile(!!vble, .data$valorf))
g <- ggplot(df, aes(y = !!vble, x = .data$cuantilComb)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
facet_wrap(vars(!!group))
} else if (length(grupos) == 2) {
# Dos grupos, un solo grafico de cuantiles (diapo 13)
x <- df %>% filter(!!group == grupos[1]) %>% pull(!!vble)
y <- df %>% filter(!!group == grupos[2]) %>% pull(!!vble)
g <- qqplot(x = x, y = y, plot.it = F) %>%
as_tibble() %>%
ggplot(aes(x = x, y = y)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
coord_fixed() +
xlab(grupos[1]) + ylab(grupos[2])
} else {
# Mas de dos grupos, matriz de scatterplots de graficos de cuantiles (diapo 18)
# Grilla con las combinaciones de los grupos, saco los que son iguales (la diagonal)
grilla <-
expand.grid(grupos, grupos, stringsAsFactors = F) %>%
rename(grupoX = .data$Var1, grupoY = .data$Var2) %>%
filter(.data$grupoX != .data$grupoY)
# Funcion auxiliar para mapply, dados los nombres de dos grupos genera los
# cuantiles a graficar gx e gy son los nombres de los grupos, devuelve un
# tibble
aux <- function(gx, gy) {
x <- df %>% filter(!!group == gx) %>% pull(!!vble)
y <- df %>% filter(!!group == gy) %>% pull(!!vble)
dat <- qqplot(x, y, plot.it = F) %>% as_tibble()
dat$varX <- gx
dat$varY <- gy
return(dat)
}
# Para cada combinacion de grupos aplicar la funcion anterior y combinar los
# resultantes tibbles
rtdo <- mapply(aux, grilla$grupoX, grilla$grupoY, SIMPLIFY = F) %>% bind_rows()
# Hago un dataset para agregar como texto los nombres de las variables en los
# paneles de la diagonal
dataTexto <- tibble(varX = grupos, varY = grupos)
# Grafico
g <- ggplot(rtdo, aes(x = x, y = y)) +
geom_point(...) +
geom_abline(aes(intercept = 0, slope = 1)) +
facet_grid(varY ~ varX) +
geom_text(data = dataTexto,
mapping = aes(y = mean(range(rtdo$y)), x = mean(range(rtdo$x)),
label = dataTexto$varX)) +
xlab(vble) + ylab(vble)
}
xlabel <- ifelse(!is.null(xlabel), xlabel,
ifelse(combined, "Quantiles of combined data",
ifelse(length(groups) == 2, grupos[1], quo_text(vble))))
ylabel <- ifelse(!is.null(ylabel), ylabel,
ifelse(combined, "Quantiles of each group",
ifelse(length(groups) == 2, grupos[2], quo_text(vble))))
g <- g + labs(x = xlabel, y = ylabel)
return(g)
}
gg_quantiles(futbol2, dist, longp)
gg_quantiles(futbol2, dist, longp,
xlabel = "Distancia (m)", ylabel = "Distancia (m)")
gg_quantiles(futbol2, dist, longp)
#' # Multiple groups
#' gg_quantiles(futbol, dist, longp)
#' gg_quantiles(futbol, dist, longp, size = 0.4, color = "red", shape = 3)
#'
#' # Only 2 grupos
#' futbol2 <- dplyr::filter(futbol, longp %in% c("< 0.81 m", "0.81 a 0.90 m"))
#' gg_quantiles(futbol2, dist, longp)
#'
#' # Each groups vs quantiles from all groups combined
#' gg_quantiles(futbol, dist, longp, combined = TRUE)
gg_quantiles <- function(df, vble, group, combined = FALSE,
xlabel = NULL, ylabel = NULL, ...) {
# NSE y controles
if (!is.data.frame(df)) stop("The object provided in the argument df is not a data.frame")
vble <- enquo(vble)
group <- enquo(group)
if (!is.numeric(eval_tidy(vble, df)))
stop(paste(quo_text(vble), "provided for the vble argument is not a numeric variable"))
if (!is.character(eval_tidy(group, df)) && !is.factor(eval_tidy(group, df)))
stop(paste(quo_text(group), "provided for the group argument is neither a character nor a factor variable"))
if (!is.logical(combined)) stop("Argument combined must be either TRUE or FALSE")
df <- ungroup(df) # si esta agrupada no deja modificar esa vble
# Identificar los grupos
grupos <- unique(pull(df, !!group))
if (length(grupos) < 2) stop("There's only one group")
if (combined) {
# Grafico de cuantiles de cada grupo vs cuantiles combinados, en paneles (diapo 37)
df <-
df %>%
group_by(!!group)  %>%
arrange(!!vble)  %>%
mutate(valorf = (row_number() - 0.5) / n())  %>%
# desagrupar para que no siga haciendo cálculos para cada grupo de longp
ungroup() %>%
# con todos los datos, calcular el cuantil que acumula la misma probabilidad que cada dato
mutate(cuantilComb = quantile(!!vble, .data$valorf))
g <- ggplot(df, aes(y = !!vble, x = .data$cuantilComb)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
facet_wrap(vars(!!group))
} else if (length(grupos) == 2) {
# Dos grupos, un solo grafico de cuantiles (diapo 13)
x <- df %>% filter(!!group == grupos[1]) %>% pull(!!vble)
y <- df %>% filter(!!group == grupos[2]) %>% pull(!!vble)
g <- qqplot(x = x, y = y, plot.it = F) %>%
as_tibble() %>%
ggplot(aes(x = x, y = y)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
coord_fixed()
} else {
# Mas de dos grupos, matriz de scatterplots de graficos de cuantiles (diapo 18)
# Grilla con las combinaciones de los grupos, saco los que son iguales (la diagonal)
grilla <-
expand.grid(grupos, grupos, stringsAsFactors = F) %>%
rename(grupoX = .data$Var1, grupoY = .data$Var2) %>%
filter(.data$grupoX != .data$grupoY)
# Funcion auxiliar para mapply, dados los nombres de dos grupos genera los
# cuantiles a graficar gx e gy son los nombres de los grupos, devuelve un
# tibble
aux <- function(gx, gy) {
x <- df %>% filter(!!group == gx) %>% pull(!!vble)
y <- df %>% filter(!!group == gy) %>% pull(!!vble)
dat <- qqplot(x, y, plot.it = F) %>% as_tibble()
dat$varX <- gx
dat$varY <- gy
return(dat)
}
# Para cada combinacion de grupos aplicar la funcion anterior y combinar los
# resultantes tibbles
rtdo <- mapply(aux, grilla$grupoX, grilla$grupoY, SIMPLIFY = F) %>% bind_rows()
# Hago un dataset para agregar como texto los nombres de las variables en los
# paneles de la diagonal
dataTexto <- tibble(varX = grupos, varY = grupos)
# Grafico
g <- ggplot(rtdo, aes(x = x, y = y)) +
geom_point(...) +
geom_abline(aes(intercept = 0, slope = 1)) +
facet_grid(varY ~ varX) +
geom_text(data = dataTexto,
mapping = aes(y = mean(range(rtdo$y)), x = mean(range(rtdo$x)),
label = dataTexto$varX))
}
xlabel <- ifelse(!is.null(xlabel), xlabel,
ifelse(combined, "Quantiles of combined data",
ifelse(length(groups) == 2, grupos[1], quo_text(vble))))
ylabel <- ifelse(!is.null(ylabel), ylabel,
ifelse(combined, "Quantiles of each group",
ifelse(length(groups) == 2, grupos[2], quo_text(vble))))
g <- g + labs(x = xlabel, y = ylabel)
return(g)
}
gg_quantiles(futbol2, dist, longp)
#' # Multiple groups
#' gg_quantiles(futbol, dist, longp)
#' gg_quantiles(futbol, dist, longp, size = 0.4, color = "red", shape = 3)
#'
#' # Only 2 grupos
#' futbol2 <- dplyr::filter(futbol, longp %in% c("< 0.81 m", "0.81 a 0.90 m"))
#' gg_quantiles(futbol2, dist, longp)
#'
#' # Each groups vs quantiles from all groups combined
#' gg_quantiles(futbol, dist, longp, combined = TRUE)
gg_quantiles <- function(df, vble, group, combined = FALSE,
xlabel = NULL, ylabel = NULL, ...) {
# NSE y controles
if (!is.data.frame(df)) stop("The object provided in the argument df is not a data.frame")
vble <- enquo(vble)
group <- enquo(group)
if (!is.numeric(eval_tidy(vble, df)))
stop(paste(quo_text(vble), "provided for the vble argument is not a numeric variable"))
if (!is.character(eval_tidy(group, df)) && !is.factor(eval_tidy(group, df)))
stop(paste(quo_text(group), "provided for the group argument is neither a character nor a factor variable"))
if (!is.logical(combined)) stop("Argument combined must be either TRUE or FALSE")
df <- ungroup(df) # si esta agrupada no deja modificar esa vble
# Identificar los grupos
grupos <- unique(pull(df, !!group))
if (length(grupos) < 2) stop("There's only one group")
if (combined) {
# Grafico de cuantiles de cada grupo vs cuantiles combinados, en paneles (diapo 37)
df <-
df %>%
group_by(!!group)  %>%
arrange(!!vble)  %>%
mutate(valorf = (row_number() - 0.5) / n())  %>%
# desagrupar para que no siga haciendo cálculos para cada grupo de longp
ungroup() %>%
# con todos los datos, calcular el cuantil que acumula la misma probabilidad que cada dato
mutate(cuantilComb = quantile(!!vble, .data$valorf))
g <- ggplot(df, aes(y = !!vble, x = .data$cuantilComb)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
facet_wrap(vars(!!group))
} else if (length(grupos) == 2) {
# Dos grupos, un solo grafico de cuantiles (diapo 13)
x <- df %>% filter(!!group == grupos[1]) %>% pull(!!vble)
y <- df %>% filter(!!group == grupos[2]) %>% pull(!!vble)
g <- qqplot(x = x, y = y, plot.it = F) %>%
as_tibble() %>%
ggplot(aes(x = x, y = y)) +
geom_point(...) +
geom_abline(intercept = 0, slope = 1) +
coord_fixed()
} else {
# Mas de dos grupos, matriz de scatterplots de graficos de cuantiles (diapo 18)
# Grilla con las combinaciones de los grupos, saco los que son iguales (la diagonal)
grilla <-
expand.grid(grupos, grupos, stringsAsFactors = F) %>%
rename(grupoX = .data$Var1, grupoY = .data$Var2) %>%
filter(.data$grupoX != .data$grupoY)
# Funcion auxiliar para mapply, dados los nombres de dos grupos genera los
# cuantiles a graficar gx e gy son los nombres de los grupos, devuelve un
# tibble
aux <- function(gx, gy) {
x <- df %>% filter(!!group == gx) %>% pull(!!vble)
y <- df %>% filter(!!group == gy) %>% pull(!!vble)
dat <- qqplot(x, y, plot.it = F) %>% as_tibble()
dat$varX <- gx
dat$varY <- gy
return(dat)
}
# Para cada combinacion de grupos aplicar la funcion anterior y combinar los
# resultantes tibbles
rtdo <- mapply(aux, grilla$grupoX, grilla$grupoY, SIMPLIFY = F) %>% bind_rows()
# Hago un dataset para agregar como texto los nombres de las variables en los
# paneles de la diagonal
dataTexto <- tibble(varX = grupos, varY = grupos)
# Grafico
g <- ggplot(rtdo, aes(x = x, y = y)) +
geom_point(...) +
geom_abline(aes(intercept = 0, slope = 1)) +
facet_grid(varY ~ varX) +
geom_text(data = dataTexto,
mapping = aes(y = mean(range(rtdo$y)), x = mean(range(rtdo$x)),
label = dataTexto$varX))
}
xlabel <- ifelse(!is.null(xlabel), xlabel,
ifelse(combined, "Quantiles of combined data",
ifelse(length(grupos) == 2, grupos[1], quo_text(vble))))
ylabel <- ifelse(!is.null(ylabel), ylabel,
ifelse(combined, "Quantiles of each group",
ifelse(length(grupos) == 2, grupos[2], quo_text(vble))))
g <- g + labs(x = xlabel, y = ylabel)
return(g)
}
gg_quantiles(futbol2, dist, longp)
gg_quantiles(futbol2, dist, longp,
xlabel = "Distancia (m)", ylabel = "Distancia (m)")
# Más de dos grupos
gg_quantiles(futbol, dist, longp, size = 0.4, color = "red", shape = 3) +
labs(title = "Gráficos QQ de a pares", x = "Distancia (m)", y = "Distancia (m)")
gg_quantiles(futbol, dist, longp, size = 0.4, color = "red", shape = 3)
futbol <-
futbol %>%
group_by(longp) %>%
mutate(ajuste = mean(dist), res = dist - ajuste)
gg_quantiles(futbol, res, longp, combined = TRUE)
devtools::load_all(".")
devtools::load_all(".")
data("futbol")
gg_quantiles(futbol2, dist, longp)
gg_quantiles(futbol, dist, longp)
gg_quantiles(futbol, dist, longp, combined = TRUE)
ggplot2::is.ggplot(gg_quantiles(futbol, dist, longp, combined = TRUE))
# Dos grupos
gg_tmd(futbol2, dist, longp)
# Múltiples grupos
gg_tmd(futbol, dist, longp)
# Múltiples grupos
gg_tmd(futbol, dist, longp, size = 0.5)
gg_rf(datos, dist, ajuste, res)
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res)
futbol <-
futbol %>%
group_by(longp) %>%
mutate(ajuste = mean(dist), res = dist - ajuste)
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res)
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res, xlabel = "Distancia (m))")
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res) + xlab("Distancia (m)")
#' datos <- dplyr::group_by(futbol, longp)
#' datos <- dplyr::mutate(datos, ajuste = mean(dist), res = dist - ajuste)
gg_rf(futbol, dist, ajuste, res, ylabel = "Distancia (m)")
# Agregando las observaciones centradas por la media general
gg_rf(futbol, dist, ajuste, res, cen_obs = TRUE, ylabel = "Distancia (m)")
gg_sl(futbol2, dist, longp)
#' @importFrom magrittr %>%
#' @importFrom dplyr enquo
#' @export
#' @examples
#' data(fusion)
#' gg_sl(fusion, time, nv.vv)
#' gg_sl(fusion, time, nv.vv, jitterwidth = 0.4, linecol = "blue",
#'       ylabel = "hola", jitteralpha = 1) +
#'       ggplot2::scale_color_discrete("Grupo")
#'
gg_sl <- function(df, vble, group,
jitterwidth = 0.1, jitteralpha = 0.5, linecol = "red",
ylabel = expression(sqrt(abs( " Residuos "))),
xlabel = "Medians") {
# NSE y controles
if (!is.data.frame(df)) stop("The object provided in the argument df is not a data.frame")
vble <- enquo(vble)
group <- enquo(group)
if (!is.numeric(eval_tidy(vble, df)))
stop(paste(quo_text(vble), "provided for the vble argument is not a numeric variable"))
if (!is.character(eval_tidy(group, df)) && !is.factor(eval_tidy(group, df)))
stop(paste(quo_text(group), "provided for the group argument is neither a character nor a factor variable"))
if (length(unique(pull(df, !!group))) < 2) stop("There's only one group")
# Calcular mediana y residuos
df1 <-
df %>%
group_by(!!group) %>%
mutate(
mna = median(!!vble),
mna_res = sqrt(abs(!!vble - .data$mna))
)
# Preparar otro data set para unir las medianas de los residuos
datos_linea <-
df1 %>%
group_by(!!group) %>%
summarise(x = median(!!vble), y = median(.data$mna_res))
# Gráfico s-l
g <- ggplot(df1, aes(x = .data$mna, y = .data$mna_res, color = !!group)) +
geom_jitter(alpha = jitteralpha, width = jitterwidth, height = 0) +
geom_line(data = datos_linea, aes(x = .data$x, y = .data$y), col = linecol) +
ylab(ylabel) + xlab(xlabel)
return(g)
}
gg_sl(futbol2, dist, longp, xlabel = "Mediana de distanci jittered (m)")
gg_pt(futbol2, dist)
gg_pt(futbol2, dist, taus = c(-1, -0.5, 0, 0.5))
# Para cada grupo por separado
gg_pt(futbol2, dist, longp, taus = c(-1, -0.5, 0, 0.5))
library(ggcleveland)
usethis::use_vignette()
usethis::use_vignette("ggplot-cleveland")
devtools::build_vignettes()
usethis::use_news_md()
usethis::use_news_md()
pkgdown::build_site()
library(ggcleveland)
devtools::build_vignettes()
pkgdown::build_site()
devtools::build_vignettes()
pkgdown::build_site()
